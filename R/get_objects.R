#' Get objects from the RATO ArcGIS Enterprise environment via the API
#'
#' @param object_ids Vector of object_ids, will be converted to character.
#' @param token Access token, by default generated by `get_token()`
#' @param batch_size Number of objects to request per API call, default is 50.
#'   Setting this to a lower number will result in more API calls, but will also
#'   reduce the risk of timeouts or errors when requesting large datasets. When
#'   set to a higher number, the API may timeout or return an error if the
#'   dataset is too large.
#'
#' @return tibble of requested objects.
#' @export
get_objects <- function(object_ids, token = get_token(), batch_size = 50) {
  # Assert that objects were requested
  assertthat::assert_that(assertthat::not_empty(object_ids))

  # Assert that batch size is a positive integer
  assertthat::assert_that(assertthat::is.count(batch_size))

  # Assert that batch size is not too big
  if (batch_size > 50) {
    warning(glue::glue(
      "Batch size is set to a higher than default value ",
      "this may result in timeouts or errors."
    ))
  }

  # Split requested object_ids into batches
  batched_ids <-
    split(object_ids, ceiling(seq_along(object_ids) / batch_size))

  # Build requests for the API
  objects_requests <-
    purrr::map(batched_ids, \(ids, token_to_use = token){
      # Collate the object id's to query and format them as expected for the API
      object_id_query <- glue::glue(
        "OBJECTID IN ({object_ids_collated})",
        object_ids_collated = glue::glue_collapse(ids, sep = ",")
      ) %>%
        curl::curl_escape()

      httr2::request("https://gis.oost-vlaanderen.be/server/rest/services/") %>%
        httr2::req_url_path_append(
          "RATO2",
          "RATO2_Dossiers_Publiek",
          "MapServer",
          "0",
          glue::glue("query?where={object_id_query}")
        ) %>%
        httr2::req_url_query(
          outFields = "*",
          f = "json",
          token = token_to_use
        )
    }) %>%
    # Set capacity of API: handle 100 outstanding requests, then wait for requests to finish
    purrr::map(~ httr2::req_throttle(.x, capacity = 100))

  # Parse the response
  objects_response <-
    objects_requests %>%
    httr2::req_perform_parallel() %>%
    purrr::map(httr2::resp_body_json)

  # Forward any error messages
  assertthat::assert_that(
    all(purrr::map_lgl(objects_response, "error", "message", .default = TRUE)),
    msg = purrr::map(objects_response, "error", "message") %>% 
      purrr::compact() %>% 
      unique()
  )

  # Pluck (so an error is returned if missing) the parts of the response we
  # want, and convert it into tabular form, then return it.

  objects_response %>%
    purrr::chuck("features") %>%
    purrr::map(~ purrr::pluck(.x, "attributes")) %>%
    # Convert every record in a single row data.frame, replace NULL with NA
    purrr::map(
      ~ as.data.frame(
        purrr::map(
          .x,
          \(field_value) {
            ifelse(is.null(field_value), NA, field_value)
          }
        )
      )
    ) %>%
    # Combine all the data.frames together so we have one row per record
    purrr::list_rbind() %>%
    return()
}
